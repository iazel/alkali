//! One-time symmetric authentication for short messages.
//!
//! This module corresponds to the [`crypto_onetimeauth`
//! API](https://doc.libsodium.org/advanced/poly1305) from Sodium.
//!
//! One-time authentication is similar in purpose to standard symmetric authentication (available
//! in the [`symmetric::auth`](crate::symmetric::auth) API). However, it has the major caveat that
//! a given key can only be used to authenticate a single message. Using the same key to
//! authentication two or more messages can result in an attacker recovering the key. The benefit
//! of one-time authentication is that it is generally much faster than a full HMAC calculation, as
//! used in normal authentication.
//!
//! One-time authentication is best suited to online protocols where lots of short messages need to
//! be authenticated. A common pattern would be to establish a shared secret key between all
//! parties, then use the [`hash::kdf` module](crate::hash::kdf) to derive an authentication key
//! for each message, and authenticate the messages with this API.
//!
//! # Algorithm Details
//! This construction is referred to as a [Message Authentication
//! Code](https://en.wikipedia.org/wiki/Message_authentication_code) (MAC).
//! In particular, this API uses [Poly1305](https://en.wikipedia.org/wiki/Poly1305).
//!
//! # Security Considerations
//! A single key must *never* be used to generate an authentication tag for more than one message.
//!
//! A common, but dangerous, mistake is to try to verify a tag by generating the tag again yourself
//! via [`authenticate`], and naively comparing the tag you calculate with the other tag. This
//! opens the door to [timing attacks](https://en.wikipedia.org/wiki/Timing_attack). The [`verify`]
//! and [`Multipart::verify`] functions use a constant-time comparison between the tags, and should
//! be used whenever you want to verify a tag, rather than comparing tags yourself.
//!
//! The length of an authentication tag generated by this API may be insufficient for the
//! authentication of very long inputs (e.g: large file transfers).
//!
//! Poly1305 is explicitly *not* a hash function, unlike many classic authentication schemes.

use crate::{hardened_buffer, require_init, AlkaliError};
use libsodium_sys as sodium;
use thiserror::Error;

/// Error type returned if something went wrong in the `one_time_auth` module.
#[derive(Clone, Copy, Debug, Eq, Error, PartialEq)]
pub enum OneTimeAuthError {
    /// Failed to authenticate a message.
    ///
    /// This may indicate an attempted forgery, a transmission error, or that you're using the
    /// wrong key. In any case, the authenticity of the message can't be verified, and it should
    /// not be trusted.
    #[error("authentication failed")]
    AuthenticationFailed,
}

/// The length of a key to authenticate a message, in bytes.
pub const KEY_LENGTH: usize = sodium::crypto_onetimeauth_poly1305_KEYBYTES as usize;

/// The length of an authentication tag, in bytes.
pub const TAG_LENGTH: usize = sodium::crypto_onetimeauth_poly1305_BYTES as usize;

hardened_buffer! {
    /// Secret key for one-time authentication.
    ///
    /// There are no technical constraints on the contents of a key, but it should be
    /// indistinguishable from random data. In general, a key will be derived as part of an online
    /// protocol, but it can be generated randomly using [`Key::generate`] if need be.
    ///
    /// A secret key should not be made public.
    ///
    /// This is a [hardened buffer type](https://docs.rs/alkali#hardened-buffer-types), and will be
    /// zeroed on drop. A number of other security measures are taken to protect its contents.
    Key(KEY_LENGTH);
}

impl Key {
    /// Generate a new, random key for use in one-time authentication.
    pub fn generate() -> Result<Self, AlkaliError> {
        require_init()?;

        let mut key = Self::new_empty()?;
        unsafe {
            // SAFETY: This function expects a pointer to a region of memory sufficient to store a
            // key for this algorithm. We have defined the `Key` type based on the
            // crypto_onetimeauth_KEYBYTES constant from Sodium, so it definitely has the correct
            // amount of space allocated to store the key. The `Key::inner_mut` method simply
            // returns a mutable pointer to the backing memory.
            sodium::crypto_onetimeauth_poly1305_keygen(key.inner_mut() as *mut libc::c_uchar);
        }
        Ok(key)
    }
}

/// A one-time authentication tag for a message.
pub type Tag = [u8; TAG_LENGTH];

/// Compute the one-time authentication tag for the given message and key.
///
/// Returns the one-time authentication tag, which is non-secret.
///
/// # Security Considerations
/// A single key must *never* be used to generate an authentication tag for more than one message.
///
/// A common, but dangerous, mistake is to try to verify a tag by generating the tag again yourself
/// via [`authenticate`], and naively comparing the tag you calculate with the other tag. This
/// opens the door to [timing attacks](https://en.wikipedia.org/wiki/Timing_attack). The [`verify`]
/// function uses a constant-time comparison between the tags, and should be used whenever you want
/// to verify a tag, rather than comparing tags yourself.
///
/// The length of an authentication tag generated by this API may be insufficient for the
/// authentication of very long inputs (e.g: large file transfers).
pub fn authenticate(message: &[u8], key: &Key) -> Result<Tag, AlkaliError> {
    require_init()?;

    let mut tag = [0u8; TAG_LENGTH];
    unsafe {
        // SAFETY: The first argument to this function is a pointer to which the calculated
        // authentication tag will be written. We have defined the `tag` buffer to be
        // `crypto_onetimeauth_BYTES` bytes long, so it is of the correct size to store a tag. The
        // next two arguments specify the message to authenticate. We use `message.len()` to
        // specify the length of the message, so it is correct for this pointer. The final argument
        // specifies the key to use for this message's authentication. We define the `Key` type to
        // be `crypto_onetimeauth_KEYBYTES` long, so it is of the expected size for use in this
        // function. The `Key::inner` method simply returns a pointer to the backing memory.
        sodium::crypto_onetimeauth_poly1305(
            tag.as_mut_ptr(),
            message.as_ptr(),
            message.len() as libc::c_ulonglong,
            key.inner() as *const libc::c_uchar,
        );
    }

    Ok(tag)
}

/// Verify that an authentication tag is valid for a given message and key.
///
/// Returns a [`OneTimeAuthError::AuthenticationFailed`] if verification of the authentication tag
/// failed.
pub fn verify(message: &[u8], tag: &Tag, key: &Key) -> Result<(), AlkaliError> {
    require_init()?;

    let verification_result = unsafe {
        // SAFETY: The first argument to this function is the authentication tag to verify. We have
        // defined the `Tag` type to be `crypto_onetimeauth_BYTES` bytes long, so it is of the
        // expected size for use here. The next two arguments specify the message to verify. We use
        // `message.len()` to specify the length of the message, so it is correct for this pointer.
        // The final argument specifies the key to use for this message's verification. We define
        // the `Key` type to be `crypto_onetimeauth_KEYBYTES` long, so it is of the expected size
        // for use in this function. The `Key::inner` method simply returns a pointer to the
        // backing memory.
        sodium::crypto_onetimeauth_poly1305_verify(
            tag.as_ptr(),
            message.as_ptr(),
            message.len() as libc::c_ulonglong,
            key.inner() as *const libc::c_uchar,
        )
    };

    if verification_result == 0 {
        Ok(())
    } else {
        Err(OneTimeAuthError::AuthenticationFailed.into())
    }
}
